#include "oklab_color_space"
#kernel paint

layout( rgba32f, set = 0, binding = 0 ) uniform image2D canvas;
layout( push_constant, std430 ) uniform Params
{
    vec2 brush_pos;
    vec2 offset;
    vec4 color;
    float radius;
    float hardness;
    float hardness_gamma;
    float flow;
}
p;

[numthreads( 8, 8, 1 )] void paint() {
    // Get absolute coordinates from tile offset
    ivec2 pixel_coords = ivec2( gl_GlobalInvocationID.xy ) + ivec2( p.offset );
    vec2 pos = vec2( pixel_coords );
    ivec2 size = imageSize( canvas );

    // Protect against writing outside the texture
    if ( pixel_coords.x >= size.x || pixel_coords.y >= size.y )
    {
        return;
    }

    // Calculate distance from the brush center
    float dist = distance( pos, p.brush_pos );

    // Draw the circle with anti-aliased edges
    if ( dist < p.radius )
    {
        // Calculate the solid core size
        float MIN_EDGE = 2.0; // Minimum anti-aliased edge width in pixels
        float max_core = max( 0.0, p.radius - MIN_EDGE );
        float core_radius = min( p.radius * p.hardness, max_core );

        // gradient from core to edge
        float aa_alpha = clamp( ( p.radius - dist ) / ( p.radius - core_radius ), 0.0, 1.0 );

        // gamma curve to shape the falloff
        aa_alpha = pow( aa_alpha, p.hardness_gamma );
        float src_a = aa_alpha * p.color.a * p.flow;

        vec4 original_color = imageLoad( canvas, pixel_coords );
        float dst_a = original_color.a;
        float out_a = src_a + dst_a * ( 1.0 - src_a );
        vec3 out_rgb = vec3( 0.0 );

        if ( out_a > 0.0 )
        {
            out_rgb = ( p.color.rgb * src_a + original_color.rgb * dst_a * ( 1.0 - src_a ) ) / out_a;
        }

        imageStore( canvas, pixel_coords, vec4( out_rgb, out_a ) );
    }
}
