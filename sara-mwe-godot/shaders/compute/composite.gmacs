#kernel composite

// Both textures are in set 0, differentiated by binding 0 and 1
layout( rgba32f, set = 0, binding = 0 ) uniform image2D canvas;
layout( rgba32f, set = 0, binding = 1 ) uniform image2D chunk;

layout( push_constant, std430 ) uniform Params
{
    vec2 offset;
    float opacity;
} p;

[numthreads( 8, 8, 1 )] void composite() {
    // Local coordinates inside the 256x256 chunk
    ivec2 chunk_coords = ivec2( gl_GlobalInvocationID.xy );

    // Global coordinates on the final canvas
    ivec2 canvas_coords = chunk_coords + ivec2( p.offset );

    ivec2 canvas_size = imageSize( canvas );
    ivec2 chunk_size = imageSize( chunk );

    // Out of bounds check for both the chunk and the canvas
    if ( chunk_coords.x >= chunk_size.x || chunk_coords.y >= chunk_size.y )
    {
        return;
    }
    if ( canvas_coords.x >= canvas_size.x || canvas_coords.y >= canvas_size.y || canvas_coords.x < 0 || canvas_coords.y < 0 )
    {
        return;
    }

    vec4 src = imageLoad( chunk, chunk_coords );
    if ( src.a <= 0.0 )
    {
        return; // Optimization: skip empty pixels
    }

    src.a *= p.opacity;

    vec4 dst = imageLoad( canvas, canvas_coords );

    // Standard Porter-Duff Over blending
    float out_a = src.a + dst.a * ( 1.0 - src.a );
    vec3 out_rgb = vec3( 0.0 );

    if ( out_a > 0.0 )
    {
        out_rgb = ( src.rgb * src.a + dst.rgb * dst.a * ( 1.0 - src.a ) ) / out_a;
    }

    imageStore( canvas, canvas_coords, vec4( out_rgb, out_a ) );
}
